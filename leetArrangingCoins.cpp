/*
*
//**********************************************************441. Arranging Coins.***************************************************

You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.

Given n, find the total number of full staircase rows that can be formed.

n is a non-negative integer and fits within the range of a 32-bit signed integer.

Example 1:

n = 5

The coins can form the following rows:
¤
¤ ¤
¤ ¤

Because the 3rd row is incomplete, we return 2.
Example 2:

n = 8

The coins can form the following rows:
¤
¤ ¤
¤ ¤ ¤
¤ ¤

Because the 4th row is incomplete, we return 3.




*******************************************************************TEST CASES:************************************************************
//These are the examples I had created, tweaked and worked on.


1
2
3
10
11
31313



// Time Complexity: O(logn).  
// Space Complexity: O(1).

//********************************************************THIS IS LEET ACCEPTED CODE.***************************************************

*/

//************************************************************Solution 1:************************************************************
//*****************************************************THIS IS LEET ACCEPTED CODE.***********************************************
// Time Complexity: O(logn).
// Space Complexity: O(1).	
// This algorithm is observation based. We get the value directly by using the formula to get the value of root of quadratic equation.
// If not we can go for binary search of appropriate number.







class Solution {
public:
    int arrangeCoins(int n) {
        return (-1+sqrt(1+8*double(n)))/2;									// Quadratic expression to the get the value of root.
    }
};






//************************************************************Solution 2:************************************************************
//*****************************************************THIS IS LEET ACCEPTED CODE.***********************************************
// Time Complexity: O(logn).
// Space Complexity: O(1).	
// This is Binary Search based algo. We take start=0, end=given value, we check whether value generated by mid value> curr. value or not? If it is
// the req. value is in lower half, else it's in upper half. Since, we iterate till l<=h, the last iteratoin will have value>target value, so
// we return l-1.


class Solution {
public:
    int arrangeCoins(int n) {
        long l=0, h=n, mid=l+(h-l)/2, target=2*long(n); 					// Setting starting and ending values of iteration.
        while(l<=h){
            // cout<<" L; "<<l<<" and high: "<<h<<endl;
            mid=l+(h-l)/2;													// Calculating middle values.
            int val=mid*(mid+1);
            if(target<mid*(mid+1)) h=mid-1;									// If calc. value>target, then req. value is in lower half.
            else l=mid+1;													// If calc. vlaue<target, then req. value is in upper half(can be
        }																	// the middle elem. even, which is handled in l-1 outside while.
        // cout<<l*(l+1)<<endl;
        return l-1;															//Returning the #level value.
    }
};